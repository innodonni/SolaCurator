Replace PraySub;
Replace SleepSub;
Replace JumpSub;
Replace JumpInSub;
Replace JumpOnSub;
Include "verblib";

[ GamePreRoutine;
#Ifdef DEBUG;
 print "GamePreRoutine: action = ", action; new_line;
#Endif;
 if (action == ##Examine or ##Search && s_obj == noun or second && location == Town) "It looks like there are more buildings down in the square.";
 if (action == ##Examine or ##Search && noun in compass && ZRegion(location.(noun.door_dir))==2 or 3) return PrintOrRun(location,noun.door_dir);
 if (action == ##Jump or ##JumpOn or ##JumpIn && RunRoutines(location, react_before)~=0) rtrue; ! include location in reactions
 Answer: if (noun == player && RunRoutines(player, before)~=0) rtrue;
 default: ;
 rfalse;
];
[ GamePostRoutine;
 if (action == ##Jump or ##JumpOn or ##JumpIn && RunRoutines(location, react_after)~=0) rtrue; ! include location in reactions
 rfalse;
];

[ ChooseObjects obj code; 
  !code = 0 if expecting to exclude from "all", 1 if expected to include in "all"
  !0	  to accept the parser's decision;
  !1	  to force the object to be included; or
  !2	  to force the object to be excluded.
  if (code < 2) { if (obj has scenery || obj == allbodyparts) return 2; rfalse; }

  ! otherwise score preferences from 1-9
  if (action_to_be == ##Eat && obj has edible) return 3;
  if (obj == altar) return 9; ! doesn't work
  if (obj == altarlegs) return 8;
  if (obj == church) return 3;
  if (obj hasnt scenery && obj ~= allbodyparts) return 2;
  return 1;
];

[ UnknownVerb word i;
  objectloop (i has transparent && i ofclass Room)
  {
    if (WordInProperty(word,i,name))
    {
      verb_wordnum=0;
      return 'go';
    }
  }
  rfalse;
];

[ ScanLoc i;
          if (i has transparent && i hasnt concealed)
          {
           if (action_to_be == ##Teleport or ##Examine or ##Search && i has visited)
            PlaceInScope(i);
           if (i has visited)
            ScopeWithin(i);
          }
];

[ ScanObj i room;
          room = ScopeCeiling(i);
          if (room has transparent && room hasnt concealed)
          {
           if (action_to_be == ##Teleport or ##Examine or ##Search)
            PlaceInScope(i);
           if (i has transparent or open)
            ScopeWithin(i);
          }
];

[ TeleportScope i;
  switch (scope_stage)
    {
      1: rfalse;
      2: objectloop (i ofclass Room) ScanLoc(i);
         objectloop (i has moved) ScanObj(i);
         if (action_to_be == ##Examine or ##Search)
          return noun ofclass Room;
         rtrue;
      3: "That doesn't seem to be anywhere you've been.";
    }
];

[ TeleportSub rm;
  if (noun ofclass Room && noun has transparent && noun hasnt concealed)
   { print "(visiting ", (the) noun, ")^"; PlayerTo (noun, 2); rtrue; }
  rm = ScopeCeiling(noun);
  if (rm ~= nothing && rm has transparent && rm hasnt concealed && rm ofclass Room)
   { print "(finding ", (the) noun, " in ", (the) rm, ")^"; PlayerTo (rm, 2); rtrue; }
  if (noun in compass) <<Go noun>>;
];

Include "grammar";

Verb 'change' = 'switch';
Verb 'mount' 'kneel' = 'enter';
Verb 'dismount' = 'exit';
Verb 'camp' 'kip' = 'sleep';
Verb 'lick' = 'taste';
Verb 'hurt' = 'hit';
Verb 'detach' = 'take';
Verb 'unchain' = 'unlock';
Verb 'wheel' = 'push';
Verb 'rifle' 'riffle' 'ransack' 'explore' = 'search';
Verb 'peek' = 'look';
Verb 'inspect' = 'examine';
Verb 'pour' = 'empty';
Verb 'grip' = 'touch';
Verb 'visit' 'travel' = 'go';

Extend 'sit'
 * 'down' 'on'/'in' supporter -> Enter
 * noun=ADirection -> Look;

Extend 'climb'
 * 'on'/'onto' noun -> Enter;

Extend 'go' first
 * scope=TeleportScope -> Teleport
 * 'near'/'nearer' 'to' scope=TeleportScope -> Teleport
 * 'near'/'nearer'/'to'/'toward'/'towards' scope=TeleportScope -> Teleport;

!Extend 'examine' first
! * scope=TeleportScope -> Examine;
Extend 'examine' last
 * noun 'to' noun=ADirection -> Examine;

Extend 'search'
 * 'through' noun -> Search
 * scope=TeleportScope -> Search
 * 'through' scope=TeleportScope -> Search;

Extend only 'check' first
 * 'in' noun -> Search;

[ MakeSub;
 if (noun ~= camp or bed) "You don't have the tools and materials for that.";
 if (location ~= Church) "This isn't an ideal spot to bed down for the night.";
 if (cushions has concealed || altar has concealed) "Ideally you would have somewhere soft to sleep.";
 if (bed hasnt general) score = score + 20; give bed general;
 deadflag = 2;
 "This is the end of the demo. Please form an orderly queue to hand in your feedback.^
 Thank you for playing!";
]; 

Verb 'make'
 * noun -> Make
 * noun noun -> Make
 * noun 'in' noun -> Make
 * 'up' noun -> Make
 * noun 'up' -> Make;

Extend 'put' first
 * 'up' noun -> Make;

Attribute legible;

[ ReadSub;
  <<Examine noun>>; 
];

Extend 'read' first
 * legible -> Read
 * legible 'about' topic -> Consult;

Verb 'lift'
 * noun -> Turn
 * noun 'up' -> Push
 * noun 'with' held -> Open;

Verb 'raise' = 'lift';

[ JumpInSub; return JumpSub(); ];
[ JumpOnSub; return JumpSub(); ];
[ JumpSub act x1;
 if (noun == nothing) noun = ScopeCeiling(player);
 act = action; x1 = noun;
 if (location ~= noun && noun has enterable) <Enter noun>;
 action=act; noun=x1; ! restore values
 if (player in noun && AfterRoutines()~=0) rtrue;
 return L__M(action, 1, noun);
];

Extend 'jump'
 * 'up'/'on' 'to' noun -> Jump
 * 'to'/'onto'/'inside' noun -> Jump;

[ WinSub;
 "If only it were that easy."; 
];
Verb "win" "lose"
 * -> Win
 * topic -> Win;

Verb "help"
 * -> Help
 * topic -> Help;

[ MyObjectListing o;
 if (o hasnt concealed)
  print "^", (The) o;
];
[ InfoSub;
 print "Type ~verbs~ for a list of actions, ~places~ for visited places, ~objects~ for items to interact with or try the following objects:";
 LoopOverScope(MyObjectListing);
];

Verb "info"
 * -> Info
 * topic -> Info;

Extend "tell" first
 * animate 'to' topic -> Tell;

[ DoSub w i;
 print "You attempt to";
 for (w=1: w<=NumberWords(): w++) {
  print (char) 32;
  for (i=0: i<WordLength(w): i++)
   print (char) WordAddress(w)->i;
 }
 ! need a full stop? check last char
 i=WordLength(w-1)-1;
 if (WordAddress(w-1)->i ~= 46) print (char) 46;
 new_line;
 rtrue;
]; 

Verb "do"
 * topic -> Do;

[ TrySub;
 "~Do or do not. There is no try.~^^Sorry, I can't understand infinitive verbs.";
];

[ SleepSub;
 if (noun == nothing) <<Make bed>>;
 if (noun has enterable) <Enter noun>;
 if (noun provides react_before) return L__M(##Sleep, 1, noun);
 <<Examine sun>>;
];

Extend 'sleep' replace
 * -> Sleep
 * 'in'/'on'/'at' noun -> Sleep;

[ PraySub;
 if (noun == nothing) <<Listen>>;
 if (noun has enterable) <Enter noun>;
 if (noun provides react_before) L__M(##Pray, 1, noun);
];

[ WorshipSub;
 if (TestScope(noun, player)) print_ret (The) noun, " ", (IsOrAre) noun, " unmoved.";
 <<Listen noun>>;
];

Extend "pray" first
 * 'in'/'on'/'at' noun -> Pray
 * 'to' 'Jesus'/'God'/'Christ'/'Allah'/'Buddha' -> Pray
 * 'to' 'the' 'gods' -> Pray
 * 'to' noun -> Worship
 * 'to' noun 'gods' -> Pray;

Extend 'listen'
 * 'at' door -> Listen;

Extend only 'say' first
 * 'prayer' -> Pray
 * 'prayer' 'to' noun -> Pray
 * 'prayer' 'in'/'on'/'at' noun -> Pray
 * 'prayer' 'to' 'Jesus'/'God'/'Christ'/'Allah'/'Buddha' -> Pray
 * 'prayer' 'to' 'the' 'gods' -> Pray
 * 'prayer' 'to' noun -> Worship
 * 'prayer' 'to' noun 'gods' -> Pray;

Extend 'look' replace
    *                                           -> Look
    * 'around'                                  -> Search
    * 'at' noun                                 -> Examine
    * 'at' noun 'to'/'towards'/'in' noun=ADirection  -> Examine
    * 'inside'/'in'/'into'/'through'/'on' noun  -> Search
    * 'under' noun                              -> LookUnder
    * noun=ADirection                           -> Examine
    * 'up' topic 'in' noun                      -> Consult reverse
    * noun -> Examine
    * 'between' door -> Search
    * 'for' noun -> Examine
    * 'to' noun=ADirection                      -> Examine;

Extend "lock" first ! try other rules after these
    * "up" noun -> Lock
    * noun "up" -> Lock;

Include ">printslow.h";
[ CheeseSample;
  PrintSlowSettings.Speed = 10;
  PrintSlowSettings.Override = false;
  printslow("^> look^");
  <Look>;
  printslow("^> inventory^");
  <Inv>;
  printslow("^> examine clothes^");
  <Examine clothes>;
  printslow("^> drop rucksack^");
  <Drop bag>;
  printslow("^> search papers^");
  <Search papers>;
];

Include ">HelpRoutines.h";
Constant NO_HELP_GRAMMAR;
Include ">NewbieGrammar.h";

Extend "give" first
 * animate 'a' 'hint' -> HintHelp
 * 'up' -> HintHelp;

Extend 'what'
 * IsAmAre 'that'/'that?'/'those'/'those?' -> NewbieGrammar
 * IsAmAre 'my' topic -> MustXMe;

Include ">ExpertGrammar.h";

Extend only 'start'
 * noun -> SwitchOn;

Extend 'bite' replace
 * edible -> Eat
 * animate -> Attack
 * noun -> Taste;

Extend only "try"
 * topic -> Try;

Extend 'use'
 * 'exit'/'entrance' -> VagueGo;

Property quip;
Include ">gtalk.h";

[TalkToSub;
  if (noun has animate) {
    "You can't think of anything to say.";
  }
  else {               !inanimate object
    if (noun has pluralname)
      print_ret (The) noun, " don't reply.";
    else
      print_ret (The) noun, " doesn't reply.";
  }
];

[NotTalkSub;
  if (noun ~= player) "To talk to someone, please type TALK TO PERSON.";
];

Extend only 'speak' replace
  * creature        -> TalkTo
  * 'to' creature   -> TalkTo
  * 'with' creature -> TalkTo
  * noun            -> TalkTo
  * 'to' noun       -> TalkTo
  * 'with' noun     -> TalkTo;

Verb 'talk' 't//'
  * creature        -> TalkTo
  * 'to' creature   -> TalkTo
  * 'with' creature -> TalkTo
  * noun            -> TalkTo
  * 'to' noun       -> TalkTo
  * 'with' noun     -> TalkTo;

! The following should be a complete list of 
! non-TALK verbs to replace, except that you
! may also want to add something like the 
! following to each of your NPC objects:
!      life [;
!        Order: NotTalkSub(); rtrue;
!      ];
! so that "MAN, GO N" is also replaced.

Extend 'answer' replace            ! = 'say' 'shout' 'speak'
  *                    -> NotTalk  ! (Except we replaced
  * topic              -> NotTalk; ! 'speak' on its own above.)
Extend 'ask' replace
  *                    -> NotTalk
  * topic              -> NotTalk;
!Extend 'tell' replace
!  *                    -> NotTalk
!  * topic              -> NotTalk;
Extend 'no' replace
  *                    -> NotTalk
  * topic              -> NotTalk;
Extend 'yes' replace               ! = 'y//'
  *                    -> NotTalk
  * topic              -> NotTalk;
Extend 'sorry' replace
  *                    -> NotTalk
  * topic              -> NotTalk;
